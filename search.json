[{"path":"https://pkg.robjhyndman.com/stR/articles/stRvignette.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Package stR","text":"many packages methods work seasonal data. example oldest method decomposition – classical additive decomposition – implemented package stats. method splits data trend, seasonal random components:  Another well known method STL, implemented packages stats stlplus:  R packages implement various versions seasonal decomposition seasonal adjustment include forecast, x12, seasonal, season, seas deseasonalize. examples provided :   looking examples, reader might ask “need another method seasonal decomposition?” short answer new STR method richer set features (allows users implement even features); method well studied theoretical background (based OLS quantile regression). vignette provides details first claim.","code":"m <- decompose(co2) plot(m) plot(stl(log(co2), s.window = \"periodic\", t.window = 30)) library(forecast) co2.fit <- tbats(co2) plot(co2.fit) library(seasonal) co2.fit <- seas(co2) plot(co2.fit, trend = TRUE)"},{"path":"https://pkg.robjhyndman.com/stR/articles/stRvignette.html","id":"getting-started","dir":"Articles","previous_headings":"","what":"Getting started","title":"Package stR","text":"time series decomposition objects class ts class msts, regressors complex seasonality, simple STR decomposition using AutoSTR function. example, co2 time series can decomposed follows:","code":"co2.fit <- AutoSTR(co2) plot(co2.fit)"},{"path":"https://pkg.robjhyndman.com/stR/articles/stRvignette.html","id":"example-with-multiple-seasonality","dir":"Articles","previous_headings":"","what":"Example with multiple seasonality","title":"Package stR","text":"time series taylor package forecast provides us half-hourly electricity demand England Wales. exhibits (least) two seasonalities – daily weekly. can observed 4 weeks’ subset data:  Since data half hour granularity, daily seasonality period 48 observations weekly period 336. data class msts (multiple seasonal time series), can also handled automatically AutoSTR:  parameters supplied AutoSTR : gapCV = 48 – gaps 48 observations used cross validation reltol = 0.001 – parameter passed directly optim function control well (long) model parameters optimized confidence = 0.95 – 95% confidence intervals calculated (assumptions: errors uncorrelated, model parameters estimated exactly)","code":"taylor.msts <- msts(log(head(as.vector(taylor), 336 * 4)),   seasonal.periods = c(48, 48 * 7, 48 * 7 * 52.25),   start = 2000 + 22 / 52 ) plot(taylor.msts, ylab = \"Electricity demand\") taylor.fit <- AutoSTR(taylor.msts, gapCV = 48, confidence = 0.95) plot(taylor.fit)"},{"path":"https://pkg.robjhyndman.com/stR/articles/stRvignette.html","id":"tuning-an-str-decomposition","dir":"Articles","previous_headings":"","what":"Tuning an STR decomposition","title":"Package stR","text":"example shows tune STR decomposition, rather use automated AutoSTR function. STR flexible method, can adjusted data multiple ways, making interface rather complex. Let us consider dataset grocery contains monthly data supermarkets grocery stores turnover New South Wales:  use log transformation stabilize seasonal variance data:  next step define trend seasonal structures. Trend seasonality, therefore seasonal structure contains single knot: c(1,0). knot defined pair numbers, referring point. segments component contains one segment c(0,1). seasonal structure data defined seasonalStructure variable. segments component contains one pair numbers c(0,12) defines ends segment, sKnots variable contains seasonal knots 1 12 (months). last knot c(0,12) also defines ends segment c(0,12) connected 0 12 represent knot (month December). Variable seasons contains months corresponding every data point: Since trend seasonality (seasonal structure trend contains one season), trend seasons ones: times vector contains times corresponding data points: data vector contains observations (case log turnover): trendTimeKnots vector contains times time knots trend positioned: seasonTimeKnots vector contains times time knots seasonal component positioned: stR package every component decomposition regressor. case trend seasonal components values regressors constants (vectors ones): complete trend structure contains components relevant trend. Component lambdas always vector three elements. Trend, since seasonality, first element different zero. element defines smoothness trend starting point optimization procedure. complete season structure contains components relevant trend. Component lambdas vector three elements. elements define smoothness seasonal component starting point optimization procedure. According STR approach every non-static seasonal component two-dimensional structure (see corresponding article STR method). particular case topology tube. “observed” seasonal component spiral subset “tube organised” data (“observed” means seasonal component observed part data together trend components). first element vector defines smoothness data along time dimension tube. second component defines smoothness along seasonal dimension. third component defines smoothness way dimensions (restricting partial discrete derivative directions). last two zeros lambdas component mean two components optimized (effectively two dimensional structure seasonal component used). components STR decomposition considered predictors. example trend predictor seasonality independent variable constant (equal one). seasonal component predictor predefined seasonality constant independent variable (also equal one). calculate STR decomposition supply data points, predictors, required confidence intervals, gap, perform cross validation, reltol parameter described earlier.  plot function forecastPanels = NULL means fit/forecast displayed. decide use two-dimensional structure seasonal component need redefine lambdas component: allows find set parameters smaller cross validated error, therefore potentially insightful decomposition:","code":"plot(grocery, ylab = \"NSW Grocery Turnover, $ 10^6\") logGr <- log(grocery) plot(logGr, ylab = \"NSW Grocery Turnover, log scale\") trendSeasonalStructure <- list(   segments = list(c(0, 1)),   sKnots = list(c(1, 0)) ) seasonalStructure <- list(   segments = list(c(0, 12)),   sKnots = list(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, c(12, 0)) ) seasons <- as.vector(cycle(logGr)) trendSeasons <- rep(1, length(logGr)) times <- as.vector(time(logGr)) data <- as.vector(logGr) trendTimeKnots <- seq(   from = head(times, 1),   to = tail(times, 1),   length.out = 175 ) seasonTimeKnots <- seq(   from = head(times, 1),   to = tail(times, 1),   length.out = 15 ) trendData <- rep(1, length(logGr)) seasonData <- rep(1, length(logGr)) trend <- list(   name = \"Trend\",   data = trendData,   times = times,   seasons = trendSeasons,   timeKnots = trendTimeKnots,   seasonalStructure = trendSeasonalStructure,   lambdas = c(0.5, 0, 0) ) season <- list(   name = \"Yearly seasonality\",   data = seasonData,   times = times,   seasons = seasons,   timeKnots = seasonTimeKnots,   seasonalStructure = seasonalStructure,   lambdas = c(10, 0, 0) ) predictors <- list(trend, season) gr.fit <- STR(data, predictors, confidence = 0.95, gap = 1, reltol = 0.00001) plot(gr.fit, xTime = times, forecastPanels = NULL) season <- list(   name = \"Yearly seasonality\",   data = seasonData,   times = times,   seasons = seasons,   timeKnots = seasonTimeKnots,   seasonalStructure = seasonalStructure,   lambdas = c(1, 1, 1) ) predictors <- list(trend, season) gr.fit <- STR(data,   predictors,   confidence = 0.95,   gap = 1,   reltol = 0.00001 ) plot(gr.fit, xTime = times, forecastPanels = NULL)"},{"path":"https://pkg.robjhyndman.com/stR/articles/stRvignette.html","id":"robust-str-decomposition","dir":"Articles","previous_headings":"","what":"Robust STR decomposition","title":"Package stR","text":"Since STR based Ordinary Least Squares (OLS), tolerate outliers well. examples compare STR robust version – Robust STR. latter based quantile regression approach (0.5 quantile used), therefore robust various types outliers. Let us create time series two “spikes” model two isolated outliers: combine grocery time series  Decomposition time series STR shows considerable distortions components:  hand Robust STR decomposition results much cleaner decomposition. outliers appear residuals (component name “Random”) trend seasonal components distorted:","code":"outl <- rep(0, length(grocery)) outl[14] <- 900 outl[113] <- -700 tsOutl <- ts(outl, start = c(2000, 1), frequency = 12) logGrOutl <- log(grocery + tsOutl) plot(logGrOutl, ylab = \"Log turnover with outliers\") trendSeasonalStructure <- list(   segments = list(c(0, 1)),   sKnots = list(c(1, 0)) ) seasonalStructure <- list(   segments = list(c(0, 12)),   sKnots = list(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, c(12, 0)) ) seasons <- as.vector(cycle(logGrOutl)) trendSeasons <- rep(1, length(logGrOutl)) times <- as.vector(time(logGrOutl)) data <- as.vector(logGrOutl) timeKnots <- times trendData <- rep(1, length(logGrOutl)) seasonData <- rep(1, length(logGrOutl)) trend <- list(   data = trendData,   times = times,   seasons = trendSeasons,   timeKnots = timeKnots,   seasonalStructure = trendSeasonalStructure,   lambdas = c(0.1, 0, 0) ) season <- list(   data = seasonData,   times = times,   seasons = seasons,   timeKnots = timeKnots,   seasonalStructure = seasonalStructure,   lambdas = c(10, 0, 0) ) predictors <- list(trend, season) fit.str <- STR(as.vector(logGrOutl), predictors, confidence = 0.95, gapCV = 1, reltol = 0.001) plot(fit.str, xTime = times, forecastPanels = NULL) fit.rstr <- STR(as.vector(logGrOutl), predictors, confidence = 0.95, gapCV = 1, reltol = 0.001, nMCIter = 200, robust = TRUE) plot(fit.rstr, xTime = times, forecastPanels = NULL)"},{"path":"https://pkg.robjhyndman.com/stR/articles/stRvignette.html","id":"another-example-with-multiple-seasonality","dir":"Articles","previous_headings":"","what":"Another example with multiple seasonality","title":"Package stR","text":"Data set calls provides data number call arrivals per 5-minute interval handled weekdays 7:00 9:05 pm March 3, 2003 large North American commercial bank. example decomposition calls data using STR:","code":"times <- as.vector(time(calls)) timeKnots <- seq(min(times), max(times), length.out = 25)  trendSeasonalStructure <- list(   segments = list(c(0, 1)),   sKnots = list(c(1, 0)) ) trendSeasons <- rep(1, length(calls))  sKnotsDays <- as.list(seq(1, 169, length.out = 169)) seasonalStructureDays <- list(   segments = list(c(1, 169)),   sKnots = sKnotsDays ) seasonsDays <- seq_along(calls) %% 169 + 1  sKnotsWeeks <- as.list(seq(0, 169 * 5, length.out = 13 * 5)) seasonalStructureWeeks <- list(   segments = list(c(0, 169 * 5)),   sKnots = sKnotsWeeks ) seasonsWeeks <- seq_along(calls) %% (169 * 5) + 1  data <- as.vector(calls) trendData <- rep(1, length(calls)) seasonData <- rep(1, length(calls))  trend <- list(   data = trendData,   times = times,   seasons = trendSeasons,   timeKnots = timeKnots,   seasonalStructure = trendSeasonalStructure,   lambdas = c(0.02, 0, 0) )  seasonDays <- list(   data = seasonData,   times = times,   seasons = seasonsDays,   timeKnots = seq(min(times), max(times), length.out = 25),   seasonalStructure = seasonalStructureDays,   lambdas = c(0, 11, 30) )  seasonWeeks <- list(   data = seasonData,   times = times,   seasons = seasonsWeeks,   timeKnots = seq(min(times), max(times), length.out = 25),   seasonalStructure = seasonalStructureWeeks,   lambdas = c(30, 500, 0.02) )  predictors <- list(trend, seasonDays, seasonWeeks) calls.fit <- STR(   data = data,   predictors = predictors,   confidence = 0.95,   reltol = 0.003,   nFold = 4,   gap = 169 ) plot(calls.fit,   xTime = as.Date(\"2003-03-03\") +     ((seq_along(data) - 1) / 169) +     (((seq_along(data) - 1) / 169) / 5) * 2,   forecastPanels = NULL )"},{"path":"https://pkg.robjhyndman.com/stR/articles/stRvignette.html","id":"a-complex-example","dir":"Articles","previous_headings":"","what":"A complex example","title":"Package stR","text":"Electricity consumption dataset electricity provides information electricity consumption Victoria, Australia 115 days starting 10th January, 2000, comprises maximum electricity demand Victoria 30-minute periods (48 observations per day). 30-minute period, dataset also provides air temperature Melbourne. example data decomposed using weekly seasonal pattern, daily seasonal pattern takes account weekends holidays transition periods , two flexible predictors:","code":"TrendSeasonalStructure <- list(   segments = list(c(0, 1)),   sKnots = list(c(1, 0)) ) DailySeasonalStructure <- list(   segments = list(c(0, 48)),   sKnots = c(as.list(1:47), list(c(48, 0))) ) WeeklySeasonalStructure <- list(   segments = list(c(0, 336)),   sKnots = c(as.list(seq(4, 332, 4)), list(c(336, 0))) ) WDSeasonalStructure <- list(   segments = list(c(0, 48), c(100, 148)),   sKnots = c(as.list(c(1:47, 101:147)), list(c(0, 48, 100, 148))) )  TrendSeasons <- rep(1, nrow(electricity)) DailySeasons <- as.vector(electricity[, \"DailySeasonality\"]) WeeklySeasons <- as.vector(electricity[, \"WeeklySeasonality\"]) WDSeasons <- as.vector(electricity[, \"WorkingDaySeasonality\"])  Data <- as.vector(electricity[, \"Consumption\"]) Times <- as.vector(electricity[, \"Time\"]) TempM <- as.vector(electricity[, \"Temperature\"]) TempM2 <- TempM^2  TrendTimeKnots <- seq(from = head(Times, 1), to = tail(Times, 1), length.out = 116) SeasonTimeKnots <- seq(from = head(Times, 1), to = tail(Times, 1), length.out = 24) SeasonTimeKnots2 <- seq(from = head(Times, 1), to = tail(Times, 1), length.out = 12)  TrendData <- rep(1, length(Times)) SeasonData <- rep(1, length(Times))  Trend <- list(   name = \"Trend\",   data = TrendData,   times = Times,   seasons = TrendSeasons,   timeKnots = TrendTimeKnots,   seasonalStructure = TrendSeasonalStructure,   lambdas = c(1500, 0, 0) ) WSeason <- list(   name = \"Weekly seas\",   data = SeasonData,   times = Times,   seasons = WeeklySeasons,   timeKnots = SeasonTimeKnots2,   seasonalStructure = WeeklySeasonalStructure,   lambdas = c(0.8, 0.6, 100) ) WDSeason <- list(   name = \"Daily seas\",   data = SeasonData,   times = Times,   seasons = WDSeasons,   timeKnots = SeasonTimeKnots,   seasonalStructure = WDSeasonalStructure,   lambdas = c(0.003, 0, 240) ) TrendTempM <- list(   name = \"Trend temp Mel\",   data = TempM,   times = Times,   seasons = TrendSeasons,   timeKnots = TrendTimeKnots,   seasonalStructure = TrendSeasonalStructure,   lambdas = c(1e7, 0, 0) ) TrendTempM2 <- list(   name = \"Trend temp Mel^2\",   data = TempM2,   times = Times,   seasons = TrendSeasons,   timeKnots = TrendTimeKnots,   seasonalStructure = TrendSeasonalStructure,   lambdas = c(1e7, 0, 0) ) Predictors <- list(Trend, WSeason, WDSeason, TrendTempM, TrendTempM2) elec.fit <- STR(   data = Data,   predictors = Predictors,   confidence = 0.95,   gapCV = 48 * 7 ) plot(elec.fit,   xTime = as.Date(\"2000-01-11\") + ((Times - 1) / 48 - 10),   forecastPanels = NULL )"},{"path":"https://pkg.robjhyndman.com/stR/articles/stRvignette.html","id":"a-forecasting-example","dir":"Articles","previous_headings":"","what":"A forecasting example","title":"Package stR","text":"example shows simple way forecasting seasonal data using STR. values, need forecast, supplied STR NAs. case going forecast last week original data. forecasting performed time model fitted. result decomposition forecasting depicted .  check meaningfulness forecast advisable plot beta coefficients decomposition. coefficients “wiggly” forecast can suboptimal. Beta coefficients trend look bit “wiggly”. explains uptrend forecast.  Beta coefficients weekly daily seasonalities look smooth end time series.  Beta coefficients temperature squared temperature predictors look smooth.  Probably, model can re-estimated higher lambda coefficient trend provide better forecast. result gets much lower cross validated mean squared error.  Beta coefficients trend, seasonal components predictors look smooth.","code":"TrendSeasonalStructure <- list(   segments = list(c(0, 1)),   sKnots = list(c(1, 0)) ) DailySeasonalStructure <- list(   segments = list(c(0, 48)),   sKnots = c(as.list(1:47), list(c(48, 0))) ) WeeklySeasonalStructure <- list(   segments = list(c(0, 336)),   sKnots = c(as.list(seq(4, 332, 4)), list(c(336, 0))) ) WDSeasonalStructure <- list(   segments = list(c(0, 48), c(100, 148)),   sKnots = c(as.list(c(1:47, 101:147)), list(c(0, 48, 100, 148))) )  TrendSeasons <- rep(1, nrow(electricity)) DailySeasons <- as.vector(electricity[, \"DailySeasonality\"]) WeeklySeasons <- as.vector(electricity[, \"WeeklySeasonality\"]) WDSeasons <- as.vector(electricity[, \"WorkingDaySeasonality\"])  Data <- as.vector(electricity[, \"Consumption\"]) Times <- as.vector(electricity[, \"Time\"]) TempM <- as.vector(electricity[, \"Temperature\"]) TempM2 <- TempM^2  TrendTimeKnots <- seq(from = head(Times, 1), to = tail(Times, 1), length.out = 116) SeasonTimeKnots <- seq(from = head(Times, 1), to = tail(Times, 1), length.out = 24) SeasonTimeKnots2 <- seq(from = head(Times, 1), to = tail(Times, 1), length.out = 12)  TrendData <- rep(1, length(Times)) SeasonData <- rep(1, length(Times))  Trend <- list(   name = \"Trend\",   data = TrendData,   times = Times,   seasons = TrendSeasons,   timeKnots = TrendTimeKnots,   seasonalStructure = TrendSeasonalStructure,   lambdas = c(1500, 0, 0) ) WSeason <- list(   name = \"Weekly seas\",   data = SeasonData,   times = Times,   seasons = WeeklySeasons,   timeKnots = SeasonTimeKnots2,   seasonalStructure = WeeklySeasonalStructure,   lambdas = c(0.8, 0.6, 100) ) WDSeason <- list(   name = \"Daily seas\",   data = SeasonData,   times = Times,   seasons = WDSeasons,   timeKnots = SeasonTimeKnots,   seasonalStructure = WDSeasonalStructure,   lambdas = c(0.003, 0, 240) ) TrendTempM <- list(   name = \"Trend temp Mel\",   data = TempM,   times = Times,   seasons = TrendSeasons,   timeKnots = TrendTimeKnots,   seasonalStructure = TrendSeasonalStructure,   lambdas = c(1e7, 0, 0) ) TrendTempM2 <- list(   name = \"Trend temp Mel^2\",   data = TempM2,   times = Times,   seasons = TrendSeasons,   timeKnots = TrendTimeKnots,   seasonalStructure = TrendSeasonalStructure,   lambdas = c(1e7, 0, 0) ) Predictors <- list(Trend, WSeason, WDSeason, TrendTempM, TrendTempM2) Data[(length(Data) - 7 * 48):length(Data)] <- NA elec.fit <- STR(   data = Data,   predictors = Predictors,   confidence = 0.95,   gapCV = 48 * 7 ) plot(elec.fit,   xTime = as.Date(\"2000-01-11\") + ((Times - 1) / 48 - 10),   forecastPanels = 7 ) plotBeta(elec.fit, predictorN = 1) plotBeta(elec.fit, predictorN = 2) plotBeta(elec.fit, predictorN = 3) plotBeta(elec.fit, predictorN = 4) plotBeta(elec.fit, predictorN = 5) Trend <- list(   name = \"Trend\",   data = TrendData,   times = Times,   seasons = TrendSeasons,   timeKnots = TrendTimeKnots,   seasonalStructure = TrendSeasonalStructure,   lambdas = c(150000, 0, 0) ) Predictors <- list(Trend, WSeason, WDSeason, TrendTempM, TrendTempM2) elec.fit.2 <- STR(   data = Data,   predictors = Predictors,   confidence = 0.95,   gapCV = 48 * 7 ) plot(elec.fit.2,   xTime = as.Date(\"2000-01-11\") + ((Times - 1) / 48 - 10),   forecastPanels = 7 ) for (i in 1:5) {   plotBeta(elec.fit.2, predictorN = i) }"},{"path":"https://pkg.robjhyndman.com/stR/articles/stRvignette.html","id":"final-notes","dir":"Articles","previous_headings":"","what":"Final notes","title":"Package stR","text":"achieve higher performance, recommended use Intel MKL matrix operations. Note, registering parallel backend using Intel MKL can reduce performance significantly since Intel MKL already tries utilise available cores. case user options use Intel MKL register parallel backend (using ordinary computer, example 4 physical cores, 8 virtual cores), recommended use Intel MKL register parallel backend. testing exploration purposes recommended avoid calculation confidence/forecasting intervals. calculation currently involves inversion big matrix can take long time. monitor progress parameters’ estimation recommended set parameter trace TRUE STR call.","code":""},{"path":"https://pkg.robjhyndman.com/stR/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Alexander Dokumentov. Author. Rob Hyndman. Author, maintainer.","code":""},{"path":"https://pkg.robjhyndman.com/stR/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Dokumentov , Hyndman R (2024). stR: STR Decomposition Time Series. R package version 0.7, https://pkg.robjhyndman.com/stR/. Dokumentov , Hyndman RJ (2021). “STR: seasonal-trend decomposition procedure based regression.” INFORMS J Data Science, 1(1), 50-62. doi:10.1287/ijds.2021.0004, http://robjhyndman.com/publications/str/.","code":"@Manual{,   title = {{stR}: STR Decomposition of Time Series},   author = {Alexander Dokumentov and Rob Hyndman},   year = {2024},   note = {R package version 0.7},   url = {https://pkg.robjhyndman.com/stR/}, } @Article{,   title = {STR: A seasonal-trend decomposition procedure based on regression},   author = {Alexander Dokumentov and Rob J Hyndman},   year = {2021},   journal = {INFORMS J on Data Science},   volume = {1},   number = {1},   pages = {50-62},   url = {http://robjhyndman.com/publications/str/},   doi = {10.1287/ijds.2021.0004}, }"},{"path":"https://pkg.robjhyndman.com/stR/index.html","id":"str","dir":"","previous_headings":"","what":"STR Decomposition of Time Series","title":"STR Decomposition of Time Series","text":"goal stR provide two methods decomposing seasonal data: STR (Seasonal-Trend decomposition procedure based Regression) Robust STR. ways, STR similar Ridge Regression Robust STR can related LASSO. allow multiple seasonal components, multiple linear covariates constant, flexible seasonal influence. Seasonal patterns (seasonal components seasonal covariates) can fractional flexible time; moreover can either strictly periodic complex topology. methods provide confidence intervals estimated components. methods can also used forecasting.","code":""},{"path":"https://pkg.robjhyndman.com/stR/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"STR Decomposition of Time Series","text":"can install release version CRAN. can install development version GitHub.","code":"install.packages('stR') # install.packages(\"remotes\") devtools::install_github(\"robjhyndman/stR\")"},{"path":"https://pkg.robjhyndman.com/stR/index.html","id":"example","dir":"","previous_headings":"","what":"Example","title":"STR Decomposition of Time Series","text":"users, AutoSTR() function preferred way using package.   See vignette advanced options.","code":"library(stR) # Decomposition of a multiple seasonal time series decomp <- AutoSTR(calls) plot(decomp) # Decomposition of a monthly time series decomp <- AutoSTR(log(grocery)) plot(decomp)"},{"path":"https://pkg.robjhyndman.com/stR/reference/AutoSTR.html","id":null,"dir":"Reference","previous_headings":"","what":"Automatic STR decomposition for time series data — AutoSTR","title":"Automatic STR decomposition for time series data — AutoSTR","text":"Automatically selects parameters STR decomposition time series data. time series class ts msts.","code":""},{"path":"https://pkg.robjhyndman.com/stR/reference/AutoSTR.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Automatic STR decomposition for time series data — AutoSTR","text":"","code":"AutoSTR(   data,   robust = FALSE,   gapCV = NULL,   lambdas = NULL,   reltol = 0.001,   confidence = NULL,   nsKnots = NULL,   trace = FALSE )"},{"path":"https://pkg.robjhyndman.com/stR/reference/AutoSTR.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Automatic STR decomposition for time series data — AutoSTR","text":"data time series class ts msts. robust TRUE, Robust STR decomposition used. Default FALSE. gapCV optional parameter defining length sequence skipped values cross validation procedure. lambdas optional parameter. structure replaces lambda parameters provided predictors. used either starting point optimisation parameters exact model parameters. reltol optional parameter passed directly optim() optimising parameters model. confidence vector percentiles giving coverage confidence intervals. must greater 0 less 1. NULL, confidence intervals produced. nsKnots optional vector parameter, defining number seasonal knots (per period) sesonal component. trace TRUE, tracing turned .","code":""},{"path":"https://pkg.robjhyndman.com/stR/reference/AutoSTR.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Automatic STR decomposition for time series data — AutoSTR","text":"structure containing input output data. S3 class STR, list following components: output – contains decomposed data. list three components: predictors – list components component corresponds input predictor. Every component list containing following: data – fit/forecast corresponding predictor (trend, seasonal component, flexible seasonal predictor). beta – beta coefficients fit coresponding predictor. lower – optional (requested) matrix lower bounds confidence intervals. upper – optional (requested) matrix upper bounds confidence intervals. random – list one component data, contains residuals model fit. forecast – list two components: data – fit/forecast model. beta – beta coefficients fit. lower – optional (requested) matrix lower bounds confidence intervals. upper – optional (requested) matrix upper bounds confidence intervals. input – input parameters lambdas used final calculations. data – input data. predictors - input predictors. lambdas – smoothing parameters used final calculations (input lambdas STR method). cvMSE – optional cross validated (leave one ) Mean Squared Error. optim.CV.MSE – best cross validated Mean Squared Error (n-fold) achieved minimisation procedure. nFold – input nFold parameter. gapCV – input gapCV parameter. method – always contains string \"AutoSTR\" function.","code":""},{"path":"https://pkg.robjhyndman.com/stR/reference/AutoSTR.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Automatic STR decomposition for time series data — AutoSTR","text":"Dokumentov, ., Hyndman, R.J. (2022) STR: Seasonal-Trend decomposition using Regression, INFORMS Journal Data Science, 1(1), 50-62. https://robjhyndman.com/publications/str/","code":""},{"path":[]},{"path":"https://pkg.robjhyndman.com/stR/reference/AutoSTR.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Automatic STR decomposition for time series data — AutoSTR","text":"Alexander Dokumentov","code":""},{"path":"https://pkg.robjhyndman.com/stR/reference/AutoSTR.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Automatic STR decomposition for time series data — AutoSTR","text":"","code":"# \\donttest{ # Decomposition of a multiple seasonal time series decomp <- AutoSTR(calls) plot(decomp)   # Decomposition of a monthly time series decomp <- AutoSTR(log(grocery)) plot(decomp)  # }"},{"path":"https://pkg.robjhyndman.com/stR/reference/RSTRmodel.html","id":null,"dir":"Reference","previous_headings":"","what":"Robust STR decomposition — RSTRmodel","title":"Robust STR decomposition — RSTRmodel","text":"Robust Seasonal-Trend decomposition time series data using Regression (robust version STRmodel).","code":""},{"path":"https://pkg.robjhyndman.com/stR/reference/RSTRmodel.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Robust STR decomposition — RSTRmodel","text":"","code":"RSTRmodel(   data,   predictors = NULL,   strDesign = NULL,   lambdas = NULL,   confidence = NULL,   nMCIter = 100,   control = list(nnzlmax = 1e+06, nsubmax = 3e+05, tmpmax = 50000),   reportDimensionsOnly = FALSE,   trace = FALSE )"},{"path":"https://pkg.robjhyndman.com/stR/reference/RSTRmodel.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Robust STR decomposition — RSTRmodel","text":"data Time series vector length L. predictors List predictors. According paradigm implementation, trend, seasonal components, flexible predictors seasonal predictors presented form (predictors) must described list. Every predictor list following structures: data – vector length L (length input data, see ). trend seasonal component vector ones. flexible seasonal predictor vector predictor's data. times – vector length L times observations. seasons – vector length L. vector ones trend flexible predictor. vector assigning seasons every observation (seasonal component seasonal predictor). Seasons can fractional observations seasons. timeKnots – vector times (time knots) knots positioned (seasonal component seasonal predictor knots time; every knot represented time season). Usually vector coincides times vector described , timeKnots subset times vector. seasonalStructure – describes seasonal topology (can complex structure) seasonal knots.seasonal topology described list segments seasonal knots, positioned inside segments, borders segments , borders, can connect two segments.seasonalStructure list two elements: segments – list vectors representing segments. vector must contain two ordered real values represent left right borders segment. Segments intersect (inside predictor). sKnots – list real values (vectors length one) vectors lengths two greater (seasonal knots) defining seasons knots (every knot represented time season). real values must belong (inside border ) segments listed segments. values represent single seasonal knot values must borders segments (single segment). case represent seasonal knot connects segments (sides one segment). lambdas – vector three values representing lambda (smoothing) parameters (time-time, season-season, time-season flexibility parameters) predictor. strDesign optional parameter used create design matrix. used internally library improve performance design matrix require full recalculation. lambdas optional parameter. structure replaces lambda parameters provided predictors. used either starting point optimisation parameters exact model parameters. confidence vector percentiles giving coverage confidence intervals. must greater 0 less 1. NULL, confidence intervals produced. nMCIter Number Monte Carlo iterations used estimate confidence intervals Robust STR decomposition. control Passed directly rq.fit.sfn() Robust STR decomposition. reportDimensionsOnly boolean parameter. TRUE method constructs design matrix reports dimensions without proceeding . mostly used debugging. trace TRUE, tracing turned .","code":""},{"path":"https://pkg.robjhyndman.com/stR/reference/RSTRmodel.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Robust STR decomposition — RSTRmodel","text":"structure containing input output data. S3 class STR, list following components: output – contains decomposed data. list three components: predictors – list components component corresponds input predictor. Every component list containing following: data – fit/forecast corresponding predictor (trend, seasonal component, flexible seasonal predictor). beta – beta coefficients fit coresponding predictor. lower – optional (requested) matrix lower bounds confidence intervals. upper – optional (requested) matrix upper bounds confidence intervals. random – list one component data, contains residuals model fit. forecast – list two components: data – fit/forecast model. beta – beta coefficients fit. lower – optional (requested) matrix lower bounds confidence intervals. upper – optional (requested) matrix upper bounds confidence intervals. input – input parameters lambdas used final calculations. data – input data. predictors - input predictors. lambdas – smoothing parameters used final calculations (input lambdas STR method). method – always contains string \"RSTRmodel\" function.","code":""},{"path":"https://pkg.robjhyndman.com/stR/reference/RSTRmodel.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Robust STR decomposition — RSTRmodel","text":"Dokumentov, ., Hyndman, R.J. (2022) STR: Seasonal-Trend decomposition using Regression, INFORMS Journal Data Science, 1(1), 50-62. https://robjhyndman.com/publications/str/","code":""},{"path":[]},{"path":"https://pkg.robjhyndman.com/stR/reference/RSTRmodel.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Robust STR decomposition — RSTRmodel","text":"Alexander Dokumentov","code":""},{"path":"https://pkg.robjhyndman.com/stR/reference/RSTRmodel.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Robust STR decomposition — RSTRmodel","text":"","code":"# \\donttest{ n <- 70 trendSeasonalStructure <- list(segments = list(c(0, 1)), sKnots = list(c(1, 0))) ns <- 5 seasonalStructure <- list(   segments = list(c(0, ns)),   sKnots = c(as.list(1:(ns - 1)), list(c(ns, 0))) ) seasons <- (0:(n - 1)) %% ns + 1 trendSeasons <- rep(1, length(seasons)) times <- seq_along(seasons) data <- seasons + times / 4 set.seed(1234567890) data <- data + rnorm(length(data), 0, 0.2) data[20] <- data[20] + 3 data[50] <- data[50] - 5 plot(times, data, type = \"l\")  timeKnots <- times trendData <- rep(1, n) seasonData <- rep(1, n) trend <- list(   data = trendData, times = times, seasons = trendSeasons,   timeKnots = timeKnots, seasonalStructure = trendSeasonalStructure, lambdas = c(1, 0, 0) ) season <- list(   data = seasonData, times = times, seasons = seasons,   timeKnots = timeKnots, seasonalStructure = seasonalStructure, lambdas = c(1, 0, 1) ) predictors <- list(trend, season) rstr <- RSTRmodel(data, predictors, confidence = 0.8) #> 'as(<dgCMatrix>, \"dgTMatrix\")' is deprecated. #> Use 'as(., \"TsparseMatrix\")' instead. #> See help(\"Deprecated\") and help(\"Matrix-deprecated\"). plot(rstr)  # }"},{"path":"https://pkg.robjhyndman.com/stR/reference/STR.html","id":null,"dir":"Reference","previous_headings":"","what":"Automatic STR decomposition — STR","title":"Automatic STR decomposition — STR","text":"Automatically selects parameters STR decomposition time series data. parallel backend registered use STR call, STR use n-fold cross validation computations.","code":""},{"path":"https://pkg.robjhyndman.com/stR/reference/STR.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Automatic STR decomposition — STR","text":"","code":"STR(   data,   predictors,   confidence = NULL,   robust = FALSE,   lambdas = NULL,   pattern = extractPattern(predictors),   nFold = 5,   reltol = 0.005,   gapCV = 1,   solver = c(\"Matrix\", \"cholesky\"),   nMCIter = 100,   control = list(nnzlmax = 1e+06, nsubmax = 3e+05, tmpmax = 50000),   trace = FALSE,   iterControl = list(maxiter = 20, tol = 1e-06) )"},{"path":"https://pkg.robjhyndman.com/stR/reference/STR.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Automatic STR decomposition — STR","text":"data Time series vector length L. predictors List predictors. According paradigm implementation, trend, seasonal components, flexible predictors seasonal predictors presented form (predictors) must described list. Every predictor list following structures: data – vector length L (length input data, see ). trend seasonal component vector ones. flexible seasonal predictor vector predictor's data. times – vector length L times observations. seasons – vector length L. vector ones trend flexible predictor. vector assigning seasons every observation (seasonal component seasonal predictor). Seasons can fractional observations seasons. timeKnots – vector times (time knots) knots positioned (seasonal component seasonal predictor knots time; every knot represented time season). Usually vector coincides times vector described , timeKnots subset times vector. seasonalStructure – describes seasonal topology (can complex structure) seasonal knots.seasonal topology described list segments seasonal knots, positioned inside segments, borders segments , borders, can connect two segments.seasonalStructure list two elements: segments – list vectors representing segments. vector must contain two ordered real values represent left right borders segment. Segments intersect (inside predictor). sKnots – list real values (vectors length one) vectors lengths two greater (seasonal knots) defining seasons knots (every knot represented time season). real values must belong (inside border ) segments listed segments. values represent single seasonal knot values must borders segments (single segment). case represent seasonal knot connects segments (sides one segment). lambdas – vector three values representing lambda (smoothing) parameters (time-time, season-season, time-season flexibility parameters) predictor. confidence vector percentiles giving coverage confidence intervals. must greater 0 less 1. NULL, confidence intervals produced. robust TRUE, Robust STR decomposition used. Default FALSE. lambdas optional parameter. structure replaces lambda parameters provided predictors. used either starting point optimisation parameters exact model parameters. pattern optional parameter structure lambdas although different meaning. zero values correspond lambda (smoothing) parameters estimated. nFold optional parameter setting number folds cross validation. reltol optional parameter passed directly optim() optimising parameters model. gapCV optional parameter defining length sequence skipped values cross validation procedure. solver vector two string values. supported combinations : c(\"Matrix\", \"cholesky\") (default), c(\"Matrix\", \"qr\"). parameter used specify particular library method solve minimisation problem STR decompositon. nMCIter Number Monte Carlo iterations used estimate confidence intervals Robust STR decomposition. control Passed directly rq.fit.sfn() Robust STR decomposition. trace TRUE, tracing turned . iterControl Control parameters experimental features. used ordinary user.","code":""},{"path":"https://pkg.robjhyndman.com/stR/reference/STR.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Automatic STR decomposition — STR","text":"structure containing input output data. S3 class STR, list following components: output – contains decomposed data. list three components: predictors – list components component corresponds input predictor. Every component list containing following: data – fit/forecast corresponding predictor (trend, seasonal component, flexible seasonal predictor). beta – beta coefficients fit coresponding predictor. lower – optional (requested) matrix lower bounds confidence intervals. upper – optional (requested) matrix upper bounds confidence intervals. random – list one component data, contains residuals model fit. forecast – list two components: data – fit/forecast model. beta – beta coefficients fit. lower – optional (requested) matrix lower bounds confidence intervals. upper – optional (requested) matrix upper bounds confidence intervals. input – input parameters lambdas used final calculations. data – input data. predictors - input predictors. lambdas – smoothing parameters used final calculations (input lambdas STR method). cvMSE – optional cross validated (leave one ) Mean Squared Error. optim.CV.MSE optim.CV.MAE – best cross validated Mean Squared Error Mean Absolute Error (n-fold) achieved minimisation procedure. nFold – input nFold parameter. gapCV – input gapCV parameter. method – contains strings \"STR\" \"RSTR\" depending used method.","code":""},{"path":"https://pkg.robjhyndman.com/stR/reference/STR.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Automatic STR decomposition — STR","text":"Dokumentov, ., Hyndman, R.J. (2022) STR: Seasonal-Trend decomposition using Regression, INFORMS Journal Data Science, 1(1), 50-62. https://robjhyndman.com/publications/str/","code":""},{"path":[]},{"path":"https://pkg.robjhyndman.com/stR/reference/STR.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Automatic STR decomposition — STR","text":"Alexander Dokumentov","code":""},{"path":"https://pkg.robjhyndman.com/stR/reference/STR.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Automatic STR decomposition — STR","text":"","code":"# \\donttest{ TrendSeasonalStructure <- list(   segments = list(c(0, 1)),   sKnots = list(c(1, 0)) ) WDSeasonalStructure <- list(   segments = list(c(0, 48), c(100, 148)),   sKnots = c(as.list(c(1:47, 101:147)), list(c(0, 48, 100, 148))) )  TrendSeasons <- rep(1, nrow(electricity)) WDSeasons <- as.vector(electricity[, \"WorkingDaySeasonality\"])  Data <- as.vector(electricity[, \"Consumption\"]) Times <- as.vector(electricity[, \"Time\"]) TempM <- as.vector(electricity[, \"Temperature\"]) TempM2 <- TempM^2  TrendTimeKnots <- seq(from = head(Times, 1), to = tail(Times, 1), length.out = 116) SeasonTimeKnots <- seq(from = head(Times, 1), to = tail(Times, 1), length.out = 24)  TrendData <- rep(1, length(Times)) SeasonData <- rep(1, length(Times))  Trend <- list(   name = \"Trend\",   data = TrendData,   times = Times,   seasons = TrendSeasons,   timeKnots = TrendTimeKnots,   seasonalStructure = TrendSeasonalStructure,   lambdas = c(1500, 0, 0) ) WDSeason <- list(   name = \"Dayly seas\",   data = SeasonData,   times = Times,   seasons = WDSeasons,   timeKnots = SeasonTimeKnots,   seasonalStructure = WDSeasonalStructure,   lambdas = c(0.003, 0, 240) ) StaticTempM <- list(   name = \"Temp Mel\",   data = TempM,   times = Times,   seasons = NULL,   timeKnots = NULL,   seasonalStructure = NULL,   lambdas = c(0, 0, 0) ) StaticTempM2 <- list(   name = \"Temp Mel^2\",   data = TempM2,   times = Times,   seasons = NULL,   timeKnots = NULL,   seasonalStructure = NULL,   lambdas = c(0, 0, 0) ) Predictors <- list(Trend, WDSeason, StaticTempM, StaticTempM2)  elec.fit <- STR(   data = Data,   predictors = Predictors,   gapCV = 48 * 7 )  plot(elec.fit,   xTime = as.Date(\"2000-01-11\") + ((Times - 1) / 48 - 10),   forecastPanels = NULL )   #########################################################  n <- 70 trendSeasonalStructure <- list(segments = list(c(0, 1)), sKnots = list(c(1, 0))) ns <- 5 seasonalStructure <- list(   segments = list(c(0, ns)),   sKnots = c(as.list(1:(ns - 1)), list(c(ns, 0))) ) seasons <- (0:(n - 1)) %% ns + 1 trendSeasons <- rep(1, length(seasons)) times <- seq_along(seasons) data <- seasons + times / 4 set.seed(1234567890) data <- data + rnorm(length(data), 0, 0.2) data[20] <- data[20] + 3 data[50] <- data[50] - 5 plot(times, data, type = \"l\")  timeKnots <- times trendData <- rep(1, n) seasonData <- rep(1, n) trend <- list(   data = trendData, times = times, seasons = trendSeasons,   timeKnots = timeKnots, seasonalStructure = trendSeasonalStructure, lambdas = c(1, 0, 0) ) season <- list(   data = seasonData, times = times, seasons = seasons,   timeKnots = timeKnots, seasonalStructure = seasonalStructure, lambdas = c(1, 0, 1) ) predictors <- list(trend, season) rstr <- STR(data, predictors,   reltol = 0.0000001, gapCV = 10,   confidence = 0.95, nMCIter = 400, robust = TRUE ) plot(rstr)  # }"},{"path":"https://pkg.robjhyndman.com/stR/reference/STRmodel.html","id":null,"dir":"Reference","previous_headings":"","what":"STR decomposition — STRmodel","title":"STR decomposition — STRmodel","text":"Seasonal-Trend decomposition time series data using Regression.","code":""},{"path":"https://pkg.robjhyndman.com/stR/reference/STRmodel.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"STR decomposition — STRmodel","text":"","code":"STRmodel(   data,   predictors = NULL,   strDesign = NULL,   lambdas = NULL,   confidence = NULL,   solver = c(\"Matrix\", \"cholesky\"),   reportDimensionsOnly = FALSE,   trace = FALSE )"},{"path":"https://pkg.robjhyndman.com/stR/reference/STRmodel.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"STR decomposition — STRmodel","text":"data Time series vector length L. predictors List predictors. According paradigm implementation, trend, seasonal components, flexible predictors seasonal predictors presented form (predictors) must described list. Every predictor list following structures: data – vector length L (length input data, see ). trend seasonal component vector ones. flexible seasonal predictor vector predictor's data. times – vector length L times observations. seasons – vector length L. vector ones trend flexible predictor. vector assigning seasons every observation (seasonal component seasonal predictor). Seasons can fractional observations seasons. timeKnots – vector times (time knots) knots positioned (seasonal component seasonal predictor knots time; every knot represented time season). Usually vector coincides times vector described , timeKnots subset times vector. seasonalStructure – describes seasonal topology (can complex structure) seasonal knots.seasonal topology described list segments seasonal knots, positioned inside segments, borders segments , borders, can connect two segments.seasonalStructure list two elements: segments – list vectors representing segments. vector must contain two ordered real values represent left right borders segment. Segments intersect (inside predictor). sKnots – list real values (vectors length one) vectors lengths two greater (seasonal knots) defining seasons knots (every knot represented time season). real values must belong (inside border ) segments listed segments. values represent single seasonal knot values must borders segments (single segment). case represent seasonal knot connects segments (sides one segment). lambdas – vector three values representing lambda (smoothing) parameters (time-time, season-season, time-season flexibility parameters) predictor. strDesign optional parameter used create design matrix. used internally library improve performance design matrix require full recalculation. lambdas optional parameter. structure replaces lambda parameters provided predictors. used either starting point optimisation parameters exact model parameters. confidence vector percentiles giving coverage confidence intervals. must greater 0 less 1. NULL, confidence intervals produced. solver vector two string values. supported combinations : c(\"Matrix\", \"cholesky\") (default), c(\"Matrix\", \"qr\"). parameter used specify particular library method solve minimisation problem STR decompositon. reportDimensionsOnly boolean parameter. TRUE method constructs design matrix reports dimensions without proceeding . mostly used debugging. trace TRUE, tracing turned .","code":""},{"path":"https://pkg.robjhyndman.com/stR/reference/STRmodel.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"STR decomposition — STRmodel","text":"structure containing input output data. S3 class STR, list following components: output – contains decomposed data. list three components: predictors – list components component corresponds input predictor. Every component list containing following: data – fit/forecast corresponding predictor (trend, seasonal component, flexible seasonal predictor). beta – beta coefficients fit coresponding predictor. lower – optional (requested) matrix lower bounds confidence intervals. upper – optional (requested) matrix upper bounds confidence intervals. random – list one component data, contains residuals model fit. forecast – list two components: data – fit/forecast model. beta – beta coefficients fit. lower – optional (requested) matrix lower bounds confidence intervals. upper – optional (requested) matrix upper bounds confidence intervals. input – input parameters lambdas used final calculations. data – input data. predictors - input predictors. lambdas – smoothing parameters used final calculations (input lambdas STR method). cvMSE – optional cross validated (leave one ) Mean Squared Error. method – always contains string \"STRmodel\" function.","code":""},{"path":"https://pkg.robjhyndman.com/stR/reference/STRmodel.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"STR decomposition — STRmodel","text":"Dokumentov, ., Hyndman, R.J. (2022) STR: Seasonal-Trend decomposition using Regression, INFORMS Journal Data Science, 1(1), 50-62. https://robjhyndman.com/publications/str/","code":""},{"path":[]},{"path":"https://pkg.robjhyndman.com/stR/reference/STRmodel.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"STR decomposition — STRmodel","text":"Alexander Dokumentov","code":""},{"path":"https://pkg.robjhyndman.com/stR/reference/STRmodel.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"STR decomposition — STRmodel","text":"","code":"n <- 50 trendSeasonalStructure <- list(segments = list(c(0, 1)), sKnots = list(c(1, 0))) ns <- 5 seasonalStructure <- list(   segments = list(c(0, ns)),   sKnots = c(as.list(1:(ns - 1)), list(c(ns, 0))) ) seasons <- (0:(n - 1)) %% ns + 1 trendSeasons <- rep(1, length(seasons)) times <- seq_along(seasons) data <- seasons + times / 4 plot(times, data, type = \"l\")  timeKnots <- times trendData <- rep(1, n) seasonData <- rep(1, n) trend <- list(   data = trendData, times = times, seasons = trendSeasons,   timeKnots = timeKnots, seasonalStructure = trendSeasonalStructure, lambdas = c(1, 0, 0) ) season <- list(   data = seasonData, times = times, seasons = seasons,   timeKnots = timeKnots, seasonalStructure = seasonalStructure, lambdas = c(10, 0, 0) ) predictors <- list(trend, season)  str1 <- STRmodel(data, predictors) plot(str1)   data[c(3, 4, 7, 20, 24, 29, 35, 37, 45)] <- NA plot(times, data, type = \"l\")  str2 <- STRmodel(data, predictors) plot(str2)"},{"path":"https://pkg.robjhyndman.com/stR/reference/calls.html","id":null,"dir":"Reference","previous_headings":"","what":"Number of phone calls dataset — calls","title":"Number of phone calls dataset — calls","text":"Number call arrivals per 5-minute interval handled weekdays 7:00 9:05 pm March 3, 2003 large North American commercial bank.","code":""},{"path":"https://pkg.robjhyndman.com/stR/reference/calls.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Number of phone calls dataset — calls","text":"","code":"calls"},{"path":"https://pkg.robjhyndman.com/stR/reference/calls.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Number of phone calls dataset — calls","text":"numerical time series class msts ts.","code":""},{"path":"https://pkg.robjhyndman.com/stR/reference/calls.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Number of phone calls dataset — calls","text":"Data file","code":""},{"path":"https://pkg.robjhyndman.com/stR/reference/calls.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Number of phone calls dataset — calls","text":"Forecasting time series complex seasonal patterns using exponential smoothing .M. De Livera, R.J. Hyndman & R.D. Snyder J American Statistical Association, 106(496), 1513-1527. https://robjhyndman.com/publications/complex-seasonality/","code":""},{"path":"https://pkg.robjhyndman.com/stR/reference/calls.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Number of phone calls dataset — calls","text":"","code":"plot(calls, ylab = \"Calls handled\")"},{"path":"https://pkg.robjhyndman.com/stR/reference/components.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract STR components — components","title":"Extract STR components — components","text":"components extracts components time series result STR decomposition.","code":""},{"path":"https://pkg.robjhyndman.com/stR/reference/components.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract STR components — components","text":"","code":"components(object)"},{"path":"https://pkg.robjhyndman.com/stR/reference/components.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract STR components — components","text":"object Result STR decomposition.","code":""},{"path":[]},{"path":"https://pkg.robjhyndman.com/stR/reference/components.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Extract STR components — components","text":"Alexander Dokumentov","code":""},{"path":"https://pkg.robjhyndman.com/stR/reference/components.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract STR components — components","text":"","code":"# \\donttest{ fit <- AutoSTR(log(grocery)) comp <- components(fit) plot(comp)  # }"},{"path":"https://pkg.robjhyndman.com/stR/reference/confidence.html","id":null,"dir":"Reference","previous_headings":"","what":"Common argument — confidence","title":"Common argument — confidence","text":"Common argument","code":""},{"path":"https://pkg.robjhyndman.com/stR/reference/confidence.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Common argument — confidence","text":"confidence vector percentiles giving coverage confidence intervals. must greater 0 less 1. NULL, confidence intervals produced.","code":""},{"path":"https://pkg.robjhyndman.com/stR/reference/control.html","id":null,"dir":"Reference","previous_headings":"","what":"Common argument — control","title":"Common argument — control","text":"Common argument","code":""},{"path":"https://pkg.robjhyndman.com/stR/reference/control.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Common argument — control","text":"control Passed directly rq.fit.sfn() Robust STR decomposition.","code":""},{"path":"https://pkg.robjhyndman.com/stR/reference/data.html","id":null,"dir":"Reference","previous_headings":"","what":"Common argument — data","title":"Common argument — data","text":"Common argument","code":""},{"path":"https://pkg.robjhyndman.com/stR/reference/data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Common argument — data","text":"data Time series vector length L.","code":""},{"path":"https://pkg.robjhyndman.com/stR/reference/electricity.html","id":null,"dir":"Reference","previous_headings":"","what":"Electricity consumption dataset — electricity","title":"Electricity consumption dataset — electricity","text":"data set provides information electricity consumption Victoria, Australia 115 days starting 10th January, 2000, comprises maximum electricity demand Victoria 30-minute periods (48 observations per day). 30-minute period, dataset also provides air temperature Melbourne.","code":""},{"path":"https://pkg.robjhyndman.com/stR/reference/electricity.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Electricity consumption dataset — electricity","text":"","code":"electricity"},{"path":"https://pkg.robjhyndman.com/stR/reference/electricity.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Electricity consumption dataset — electricity","text":"numerical matrix class msts ts.","code":""},{"path":"https://pkg.robjhyndman.com/stR/reference/electricity.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Electricity consumption dataset — electricity","text":"Consumption column contains maximum electricity consumption 30 minute periods Temperature column contains temperature Melbourne corresponding 30 minute interval Time column contains number 30 minute interval dataset DailySeasonality column contains positions 30 minute interval inside days WeeklySeasonality column contains positions 30 minute interval inside weeks WorkingDaySeasonality column contains positions 30 minute intervals inside working day/holiday transition diagram","code":""},{"path":"https://pkg.robjhyndman.com/stR/reference/electricity.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Electricity consumption dataset — electricity","text":"","code":"plot(electricity[, 1:2],   xlab = \"Weeks\",   main = \"Electricity demand and temperature in Melbourne, Australia\" )"},{"path":"https://pkg.robjhyndman.com/stR/reference/gapCV.html","id":null,"dir":"Reference","previous_headings":"","what":"Common argument — gapCV","title":"Common argument — gapCV","text":"Common argument","code":""},{"path":"https://pkg.robjhyndman.com/stR/reference/gapCV.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Common argument — gapCV","text":"gapCV optional parameter defining length sequence skipped values cross validation procedure.","code":""},{"path":"https://pkg.robjhyndman.com/stR/reference/grocery.html","id":null,"dir":"Reference","previous_headings":"","what":"Grocery and supermarkets turnover — grocery","title":"Grocery and supermarkets turnover — grocery","text":"Turnover supermarkets grocery stores New South Wales, Australia.","code":""},{"path":"https://pkg.robjhyndman.com/stR/reference/grocery.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Grocery and supermarkets turnover — grocery","text":"","code":"grocery"},{"path":"https://pkg.robjhyndman.com/stR/reference/grocery.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Grocery and supermarkets turnover — grocery","text":"object class ts.","code":""},{"path":"https://pkg.robjhyndman.com/stR/reference/grocery.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Grocery and supermarkets turnover — grocery","text":"Australian Bureau Statistics, CAT 8501.0. (TABLE 11. Retail Turnover, State Industry Subgroup, Original)","code":""},{"path":"https://pkg.robjhyndman.com/stR/reference/grocery.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Grocery and supermarkets turnover — grocery","text":"","code":"plot(grocery, ylab = \"NSW Grocery, $ 10^6\")"},{"path":"https://pkg.robjhyndman.com/stR/reference/heuristicSTR.html","id":null,"dir":"Reference","previous_headings":"","what":"Automatic STR decomposition with heuristic search of the parameters — heuristicSTR","title":"Automatic STR decomposition with heuristic search of the parameters — heuristicSTR","text":"Automatically selects parameters (lambda coefficients) STR decomposition time series data. Heuristic approach can give better estimate compare standard optmisaton methods used STR. parallel backend registered use STR call, heuristicSTR use n-fold cross validation computations.","code":""},{"path":"https://pkg.robjhyndman.com/stR/reference/heuristicSTR.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Automatic STR decomposition with heuristic search of the parameters — heuristicSTR","text":"","code":"heuristicSTR(   data,   predictors,   confidence = NULL,   lambdas = NULL,   pattern = extractPattern(predictors),   nFold = 5,   reltol = 0.005,   gapCV = 1,   solver = c(\"Matrix\", \"cholesky\"),   trace = FALSE,   ratioGap = 1e+12,   relCV = 0.01 )"},{"path":"https://pkg.robjhyndman.com/stR/reference/heuristicSTR.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Automatic STR decomposition with heuristic search of the parameters — heuristicSTR","text":"data Time series vector length L. predictors List predictors. According paradigm implementation, trend, seasonal components, flexible predictors seasonal predictors presented form (predictors) must described list. Every predictor list following structures: data – vector length L (length input data, see ). trend seasonal component vector ones. flexible seasonal predictor vector predictor's data. times – vector length L times observations. seasons – vector length L. vector ones trend flexible predictor. vector assigning seasons every observation (seasonal component seasonal predictor). Seasons can fractional observations seasons. timeKnots – vector times (time knots) knots positioned (seasonal component seasonal predictor knots time; every knot represented time season). Usually vector coincides times vector described , timeKnots subset times vector. seasonalStructure – describes seasonal topology (can complex structure) seasonal knots.seasonal topology described list segments seasonal knots, positioned inside segments, borders segments , borders, can connect two segments.seasonalStructure list two elements: segments – list vectors representing segments. vector must contain two ordered real values represent left right borders segment. Segments intersect (inside predictor). sKnots – list real values (vectors length one) vectors lengths two greater (seasonal knots) defining seasons knots (every knot represented time season). real values must belong (inside border ) segments listed segments. values represent single seasonal knot values must borders segments (single segment). case represent seasonal knot connects segments (sides one segment). lambdas – vector three values representing lambda (smoothing) parameters (time-time, season-season, time-season flexibility parameters) predictor. confidence vector percentiles giving coverage confidence intervals. must greater 0 less 1. NULL, confidence intervals produced. lambdas optional parameter. structure replaces lambda parameters provided predictors. used either starting point optimisation parameters exact model parameters. pattern optional parameter structure lambdas although different meaning. zero values correspond lambda (smoothing) parameters estimated. nFold optional parameter setting number folds cross validation. reltol optional parameter passed directly optim() optimising parameters model. gapCV optional parameter defining length sequence skipped values cross validation procedure. solver vector two string values. supported combinations : c(\"Matrix\", \"cholesky\") (default), c(\"Matrix\", \"qr\"). parameter used specify particular library method solve minimisation problem STR decompositon. trace TRUE, tracing turned . ratioGap Ratio define hyperparameter bounds one-dimensional search. relCV Minimum improvement required predictors tried. used exit heuristic serach lambda parameters.","code":""},{"path":"https://pkg.robjhyndman.com/stR/reference/heuristicSTR.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Automatic STR decomposition with heuristic search of the parameters — heuristicSTR","text":"structure containing input output data. S3 class STR, list following components: output – contains decomposed data. list three components: predictors – list components component corresponds input predictor. Every component list containing following: data – fit/forecast corresponding predictor (trend, seasonal component, flexible seasonal predictor). beta – beta coefficients fit coresponding predictor. lower – optional (requested) matrix lower bounds confidence intervals. upper – optional (requested) matrix upper bounds confidence intervals. random – list one component data, contains residuals model fit. forecast – list two components: data – fit/forecast model. beta – beta coefficients fit. lower – optional (requested) matrix lower bounds confidence intervals. upper – optional (requested) matrix upper bounds confidence intervals. input – input parameters lambdas used final calculations. data – input data. predictors - input predictors. lambdas – smoothing parameters used final calculations (input lambdas STR method). cvMSE – optional cross validated (leave one ) Mean Squared Error. optim.CV.MSE optim.CV.MAE – best cross validated Mean Squared Error Mean Absolute Error (n-fold) achieved minimisation procedure. nFold – input nFold parameter. gapCV – input gapCV parameter. method – contains strings \"STR\" \"RSTR\" depending used method.","code":""},{"path":"https://pkg.robjhyndman.com/stR/reference/heuristicSTR.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Automatic STR decomposition with heuristic search of the parameters — heuristicSTR","text":"Dokumentov, ., Hyndman, R.J. (2022) STR: Seasonal-Trend decomposition using Regression, INFORMS Journal Data Science, 1(1), 50-62. https://robjhyndman.com/publications/str/","code":""},{"path":[]},{"path":"https://pkg.robjhyndman.com/stR/reference/heuristicSTR.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Automatic STR decomposition with heuristic search of the parameters — heuristicSTR","text":"Alexander Dokumentov","code":""},{"path":"https://pkg.robjhyndman.com/stR/reference/heuristicSTR.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Automatic STR decomposition with heuristic search of the parameters — heuristicSTR","text":"","code":"# \\donttest{ TrendSeasonalStructure <- list(   segments = list(c(0, 1)),   sKnots = list(c(1, 0)) ) WDSeasonalStructure <- list(   segments = list(c(0, 48), c(100, 148)),   sKnots = c(as.list(c(1:47, 101:147)), list(c(0, 48, 100, 148))) )  TrendSeasons <- rep(1, nrow(electricity)) WDSeasons <- as.vector(electricity[, \"WorkingDaySeasonality\"])  Data <- as.vector(electricity[, \"Consumption\"]) Times <- as.vector(electricity[, \"Time\"]) TempM <- as.vector(electricity[, \"Temperature\"]) TempM2 <- TempM^2  TrendTimeKnots <- seq(from = head(Times, 1), to = tail(Times, 1), length.out = 116) SeasonTimeKnots <- seq(from = head(Times, 1), to = tail(Times, 1), length.out = 24)  TrendData <- rep(1, length(Times)) SeasonData <- rep(1, length(Times))  Trend <- list(   name = \"Trend\",   data = TrendData,   times = Times,   seasons = TrendSeasons,   timeKnots = TrendTimeKnots,   seasonalStructure = TrendSeasonalStructure,   lambdas = c(1500, 0, 0) ) WDSeason <- list(   name = \"Dayly seas\",   data = SeasonData,   times = Times,   seasons = WDSeasons,   timeKnots = SeasonTimeKnots,   seasonalStructure = WDSeasonalStructure,   lambdas = c(0.003, 0, 240) ) StaticTempM <- list(   name = \"Temp Mel\",   data = TempM,   times = Times,   seasons = NULL,   timeKnots = NULL,   seasonalStructure = NULL,   lambdas = c(0, 0, 0) ) StaticTempM2 <- list(   name = \"Temp Mel^2\",   data = TempM2,   times = Times,   seasons = NULL,   timeKnots = NULL,   seasonalStructure = NULL,   lambdas = c(0, 0, 0) ) Predictors <- list(Trend, WDSeason, StaticTempM, StaticTempM2)  elec.fit <- heuristicSTR(   data = Data,   predictors = Predictors,   gapCV = 48 * 7 )  plot(elec.fit,   xTime = as.Date(\"2000-01-11\") + ((Times - 1) / 48 - 10),   forecastPanels = NULL )   ########################################  TrendSeasonalStructure <- list(   segments = list(c(0, 1)),   sKnots = list(c(1, 0)) ) DailySeasonalStructure <- list(   segments = list(c(0, 48)),   sKnots = c(as.list(1:47), list(c(48, 0))) ) WeeklySeasonalStructure <- list(   segments = list(c(0, 336)),   sKnots = c(as.list(seq(4, 332, 4)), list(c(336, 0))) ) WDSeasonalStructure <- list(   segments = list(c(0, 48), c(100, 148)),   sKnots = c(as.list(c(1:47, 101:147)), list(c(0, 48, 100, 148))) )  TrendSeasons <- rep(1, nrow(electricity)) DailySeasons <- as.vector(electricity[, \"DailySeasonality\"]) WeeklySeasons <- as.vector(electricity[, \"WeeklySeasonality\"]) WDSeasons <- as.vector(electricity[, \"WorkingDaySeasonality\"])  Data <- as.vector(electricity[, \"Consumption\"]) Times <- as.vector(electricity[, \"Time\"]) TempM <- as.vector(electricity[, \"Temperature\"]) TempM2 <- TempM^2  TrendTimeKnots <- seq(from = head(Times, 1), to = tail(Times, 1), length.out = 116) SeasonTimeKnots <- seq(from = head(Times, 1), to = tail(Times, 1), length.out = 24) SeasonTimeKnots2 <- seq(from = head(Times, 1), to = tail(Times, 1), length.out = 12)  TrendData <- rep(1, length(Times)) SeasonData <- rep(1, length(Times))  Trend <- list(   name = \"Trend\",   data = TrendData,   times = Times,   seasons = TrendSeasons,   timeKnots = TrendTimeKnots,   seasonalStructure = TrendSeasonalStructure,   lambdas = c(1500, 0, 0) ) WSeason <- list(   name = \"Weekly seas\",   data = SeasonData,   times = Times,   seasons = WeeklySeasons,   timeKnots = SeasonTimeKnots2,   seasonalStructure = WeeklySeasonalStructure,   lambdas = c(0.8, 0.6, 100) ) WDSeason <- list(   name = \"Dayly seas\",   data = SeasonData,   times = Times,   seasons = WDSeasons,   timeKnots = SeasonTimeKnots,   seasonalStructure = WDSeasonalStructure,   lambdas = c(0.003, 0, 240) ) TrendTempM <- list(   name = \"Trend temp Mel\",   data = TempM,   times = Times,   seasons = TrendSeasons,   timeKnots = TrendTimeKnots,   seasonalStructure = TrendSeasonalStructure,   lambdas = c(1e7, 0, 0) ) TrendTempM2 <- list(   name = \"Trend temp Mel^2\",   data = TempM2,   times = Times,   seasons = TrendSeasons,   timeKnots = TrendTimeKnots,   seasonalStructure = TrendSeasonalStructure,   lambdas = c(0.01, 0, 0) ) # Starting parameter is too far from the optimal value Predictors <- list(Trend, WSeason, WDSeason, TrendTempM, TrendTempM2)  elec.fit <- heuristicSTR(   data = Data,   predictors = Predictors,   gapCV = 48 * 7 )  plot(elec.fit,   xTime = as.Date(\"2000-01-11\") + ((Times - 1) / 48 - 10),   forecastPanels = NULL )   plotBeta(elec.fit, predictorN = 4)  plotBeta(elec.fit, predictorN = 5)  # }"},{"path":"https://pkg.robjhyndman.com/stR/reference/lambdas.html","id":null,"dir":"Reference","previous_headings":"","what":"Common argument — lambdas","title":"Common argument — lambdas","text":"Common argument","code":""},{"path":"https://pkg.robjhyndman.com/stR/reference/lambdas.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Common argument — lambdas","text":"lambdas optional parameter. structure replaces lambda parameters provided predictors. used either starting point optimisation parameters exact model parameters.","code":""},{"path":"https://pkg.robjhyndman.com/stR/reference/nFold.html","id":null,"dir":"Reference","previous_headings":"","what":"Common argument — nFold","title":"Common argument — nFold","text":"Common argument","code":""},{"path":"https://pkg.robjhyndman.com/stR/reference/nFold.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Common argument — nFold","text":"nFold optional parameter setting number folds cross validation.","code":""},{"path":"https://pkg.robjhyndman.com/stR/reference/nMCIter.html","id":null,"dir":"Reference","previous_headings":"","what":"Common argument — nMCIter","title":"Common argument — nMCIter","text":"Common argument","code":""},{"path":"https://pkg.robjhyndman.com/stR/reference/nMCIter.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Common argument — nMCIter","text":"nMCIter Number Monte Carlo iterations used estimate confidence intervals Robust STR decomposition.","code":""},{"path":"https://pkg.robjhyndman.com/stR/reference/pattern.html","id":null,"dir":"Reference","previous_headings":"","what":"Common argument — pattern","title":"Common argument — pattern","text":"Common argument","code":""},{"path":"https://pkg.robjhyndman.com/stR/reference/pattern.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Common argument — pattern","text":"pattern optional parameter structure lambdas although different meaning. zero values correspond lambda (smoothing) parameters estimated.","code":""},{"path":"https://pkg.robjhyndman.com/stR/reference/plot.STR.html","id":null,"dir":"Reference","previous_headings":"","what":"Plots the results of decomposition — plot.STR","title":"Plots the results of decomposition — plot.STR","text":"plot.STR plots results STR decomposition.","code":""},{"path":"https://pkg.robjhyndman.com/stR/reference/plot.STR.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plots the results of decomposition — plot.STR","text":"","code":"# S3 method for class 'STR' plot(   x,   xTime = NULL,   dataPanels = 1,   predictorPanels = as.list(seq_along(x$output$predictors)),   randomPanels = length(x$output$predictors) + 1,   forecastPanels = length(x$output$predictors) + 2,   dataColor = \"black\",   predictorColors = rep(\"red\", length(x$output$predictors)),   randomColor = \"red\",   forecastColor = \"blue\",   vLines = NULL,   xlab = \"Time\",   main = ifelse(x$method %in% c(\"STR\", \"STRmodel\"), \"STR decomposition\",     \"Robust STR decomposition\"),   showLegend = TRUE,   ... )"},{"path":"https://pkg.robjhyndman.com/stR/reference/plot.STR.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plots the results of decomposition — plot.STR","text":"x Result STR decomposition. xTime Times data plot. dataPanels Vector panel numbers plot original data. Set NULL show data. predictorPanels list vectors numbers every vector describes panels used plotting corresponding predictor. randomPanels Vector panel numbers plot residuals.  Set NULL show residuals. forecastPanels Vector panel numbers plot fit/forecast.  Set NULL show forecasts. dataColor Color plot data. predictorColors Vector colors plot components corresponding predictors. randomColor Color plot residuals. forecastColor Color plot fit/forecast. vLines Vector times vertical lines plotted. xlab Label horizontal axis. main Main heading plot. showLegend TRUE (default) legend shown top plot. ... parameters passed directly plot lines functions implementation.","code":""},{"path":[]},{"path":"https://pkg.robjhyndman.com/stR/reference/plot.STR.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Plots the results of decomposition — plot.STR","text":"Alexander Dokumentov","code":""},{"path":"https://pkg.robjhyndman.com/stR/reference/plot.STR.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plots the results of decomposition — plot.STR","text":"","code":"# \\donttest{ fit <- AutoSTR(log(grocery)) plot(fit, forecastPanels = 0, randomColor = \"DarkGreen\", vLines = 2000:2010, lwd = 2)  # }"},{"path":"https://pkg.robjhyndman.com/stR/reference/plotBeta.html","id":null,"dir":"Reference","previous_headings":"","what":"Plots the varying beta coefficients of decomposition — plotBeta","title":"Plots the varying beta coefficients of decomposition — plotBeta","text":"plotBeta plots varying beta coefficients STR decomposition. plots coefficients independent seasons (one less season defined).","code":""},{"path":"https://pkg.robjhyndman.com/stR/reference/plotBeta.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plots the varying beta coefficients of decomposition — plotBeta","text":"","code":"plotBeta(   x,   xTime = NULL,   predictorN = 1,   dim = c(1, 2, 3),   type = \"o\",   pch = 20,   palette = function(n) rainbow(n, start = 0, end = 0.7) )"},{"path":"https://pkg.robjhyndman.com/stR/reference/plotBeta.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plots the varying beta coefficients of decomposition — plotBeta","text":"x Result STR decomposition. xTime Times data plot. predictorN Predictor number decomposition plot corresponding beta coefficiets. dim Dimensions use plot beta coefficients. 1, standard charts used. 2, graphics:::filled.contour function used. 3, rgl:::persp3d used. default value 1. type Type graph one dimensional plots. pch Symbol code plot points 1-dimensional charts. Default value 20. palette Color palette 2 - 3 - dimentional plots.","code":""},{"path":[]},{"path":"https://pkg.robjhyndman.com/stR/reference/plotBeta.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Plots the varying beta coefficients of decomposition — plotBeta","text":"Alexander Dokumentov","code":""},{"path":"https://pkg.robjhyndman.com/stR/reference/plotBeta.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plots the varying beta coefficients of decomposition — plotBeta","text":"","code":"# \\donttest{ fit <- AutoSTR(log(grocery)) for (i in 1:2) plotBeta(fit, predictorN = i, dim = 2)    ########################################  TrendSeasonalStructure <- list(   segments = list(c(0, 1)),   sKnots = list(c(1, 0)) ) DailySeasonalStructure <- list(   segments = list(c(0, 48)),   sKnots = c(as.list(1:47), list(c(48, 0))) ) WeeklySeasonalStructure <- list(   segments = list(c(0, 336)),   sKnots = c(as.list(seq(4, 332, 4)), list(c(336, 0))) ) WDSeasonalStructure <- list(   segments = list(c(0, 48), c(100, 148)),   sKnots = c(as.list(c(1:47, 101:147)), list(c(0, 48, 100, 148))) )  TrendSeasons <- rep(1, nrow(electricity)) DailySeasons <- as.vector(electricity[, \"DailySeasonality\"]) WeeklySeasons <- as.vector(electricity[, \"WeeklySeasonality\"]) WDSeasons <- as.vector(electricity[, \"WorkingDaySeasonality\"])  Data <- as.vector(electricity[, \"Consumption\"]) Times <- as.vector(electricity[, \"Time\"]) TempM <- as.vector(electricity[, \"Temperature\"]) TempM2 <- TempM^2  TrendTimeKnots <- seq(from = head(Times, 1), to = tail(Times, 1), length.out = 116) SeasonTimeKnots <- seq(from = head(Times, 1), to = tail(Times, 1), length.out = 24) SeasonTimeKnots2 <- seq(from = head(Times, 1), to = tail(Times, 1), length.out = 12)  TrendData <- rep(1, length(Times)) SeasonData <- rep(1, length(Times))  Trend <- list(   name = \"Trend\",   data = TrendData,   times = Times,   seasons = TrendSeasons,   timeKnots = TrendTimeKnots,   seasonalStructure = TrendSeasonalStructure,   lambdas = c(1500, 0, 0) ) WSeason <- list(   name = \"Weekly seas\",   data = SeasonData,   times = Times,   seasons = WeeklySeasons,   timeKnots = SeasonTimeKnots2,   seasonalStructure = WeeklySeasonalStructure,   lambdas = c(0.8, 0.6, 100) ) WDSeason <- list(   name = \"Dayly seas\",   data = SeasonData,   times = Times,   seasons = WDSeasons,   timeKnots = SeasonTimeKnots,   seasonalStructure = WDSeasonalStructure,   lambdas = c(0.003, 0, 240) ) TrendTempM <- list(   name = \"Trend temp Mel\",   data = TempM,   times = Times,   seasons = TrendSeasons,   timeKnots = TrendTimeKnots,   seasonalStructure = TrendSeasonalStructure,   lambdas = c(1e7, 0, 0) ) TrendTempM2 <- list(   name = \"Trend temp Mel^2\",   data = TempM2,   times = Times,   seasons = TrendSeasons,   timeKnots = TrendTimeKnots,   seasonalStructure = TrendSeasonalStructure,   lambdas = c(0.01, 0, 0) ) # Starting parameter is too far from the optimal value Predictors <- list(Trend, WSeason, WDSeason, TrendTempM, TrendTempM2)  elec.fit <- STR(   data = Data,   predictors = Predictors,   gapCV = 48 * 7 )  plot(elec.fit,   xTime = as.Date(\"2000-01-11\") + ((Times - 1) / 48 - 10),   forecastPanels = NULL )   plotBeta(elec.fit, predictorN = 4)  plotBeta(elec.fit, predictorN = 5) # Beta coefficients are too \"wiggly\"  # }"},{"path":"https://pkg.robjhyndman.com/stR/reference/predictors.html","id":null,"dir":"Reference","previous_headings":"","what":"Common argument — predictors","title":"Common argument — predictors","text":"Common argument","code":""},{"path":"https://pkg.robjhyndman.com/stR/reference/predictors.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Common argument — predictors","text":"predictors List predictors. According paradigm implementation, trend, seasonal components, flexible predictors seasonal predictors presented form (predictors) must described list. Every predictor list following structures: data – vector length L (length input data, see ). trend seasonal component vector ones. flexible seasonal predictor vector predictor's data. times – vector length L times observations. seasons – vector length L. vector ones trend flexible predictor. vector assigning seasons every observation (seasonal component seasonal predictor). Seasons can fractional observations seasons. timeKnots – vector times (time knots) knots positioned (seasonal component seasonal predictor knots time; every knot represented time season). Usually vector coincides times vector described , timeKnots subset times vector. seasonalStructure – describes seasonal topology (can complex structure) seasonal knots.seasonal topology described list segments seasonal knots, positioned inside segments, borders segments , borders, can connect two segments.seasonalStructure list two elements: segments – list vectors representing segments. vector must contain two ordered real values represent left right borders segment. Segments intersect (inside predictor). sKnots – list real values (vectors length one) vectors lengths two greater (seasonal knots) defining seasons knots (every knot represented time season). real values must belong (inside border ) segments listed segments. values represent single seasonal knot values must borders segments (single segment). case represent seasonal knot connects segments (sides one segment). lambdas – vector three values representing lambda (smoothing) parameters (time-time, season-season, time-season flexibility parameters) predictor.","code":""},{"path":"https://pkg.robjhyndman.com/stR/reference/reexports.html","id":null,"dir":"Reference","previous_headings":"","what":"Objects exported from other packages — reexports","title":"Objects exported from other packages — reexports","text":"objects imported packages. Follow links see documentation. forecast seasadj","code":""},{"path":"https://pkg.robjhyndman.com/stR/reference/reltol.html","id":null,"dir":"Reference","previous_headings":"","what":"Common argument — reltol","title":"Common argument — reltol","text":"Common argument","code":""},{"path":"https://pkg.robjhyndman.com/stR/reference/reltol.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Common argument — reltol","text":"reltol optional parameter passed directly optim() optimising parameters model.","code":""},{"path":"https://pkg.robjhyndman.com/stR/reference/reportDimensionsOnly.html","id":null,"dir":"Reference","previous_headings":"","what":"Common argument — reportDimensionsOnly","title":"Common argument — reportDimensionsOnly","text":"Common argument","code":""},{"path":"https://pkg.robjhyndman.com/stR/reference/reportDimensionsOnly.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Common argument — reportDimensionsOnly","text":"reportDimensionsOnly boolean parameter. TRUE method constructs design matrix reports dimensions without proceeding . mostly used debugging.","code":""},{"path":"https://pkg.robjhyndman.com/stR/reference/robust.html","id":null,"dir":"Reference","previous_headings":"","what":"Common argument — robust","title":"Common argument — robust","text":"Common argument","code":""},{"path":"https://pkg.robjhyndman.com/stR/reference/robust.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Common argument — robust","text":"robust TRUE, Robust STR decomposition used. Default FALSE.","code":""},{"path":"https://pkg.robjhyndman.com/stR/reference/seasadj.STR.html","id":null,"dir":"Reference","previous_headings":"","what":"Seasonal adjustment based on STR — seasadj.STR","title":"Seasonal adjustment based on STR — seasadj.STR","text":"seasadj.STR extracts seasonally adjusted data removing seasonal components result STR decomposition.","code":""},{"path":"https://pkg.robjhyndman.com/stR/reference/seasadj.STR.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Seasonal adjustment based on STR — seasadj.STR","text":"","code":"# S3 method for class 'STR' seasadj(object, include = c(\"Trend\", \"Random\"), ...)"},{"path":"https://pkg.robjhyndman.com/stR/reference/seasadj.STR.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Seasonal adjustment based on STR — seasadj.STR","text":"object Result STR decomposition. include Vector component names include result. default c(\"Trend\", \"Random\"). ... arguments currently used.","code":""},{"path":[]},{"path":"https://pkg.robjhyndman.com/stR/reference/seasadj.STR.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Seasonal adjustment based on STR — seasadj.STR","text":"Alexander Dokumentov","code":""},{"path":"https://pkg.robjhyndman.com/stR/reference/seasadj.STR.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Seasonal adjustment based on STR — seasadj.STR","text":"","code":"# \\donttest{ fit <- AutoSTR(log(grocery)) plot(seasadj(fit))  # }"},{"path":"https://pkg.robjhyndman.com/stR/reference/solver.html","id":null,"dir":"Reference","previous_headings":"","what":"Common argument — solver","title":"Common argument — solver","text":"Common argument","code":""},{"path":"https://pkg.robjhyndman.com/stR/reference/solver.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Common argument — solver","text":"solver vector two string values. supported combinations : c(\"Matrix\", \"cholesky\") (default), c(\"Matrix\", \"qr\"). parameter used specify particular library method solve minimisation problem STR decompositon.","code":""},{"path":"https://pkg.robjhyndman.com/stR/reference/strDesign.html","id":null,"dir":"Reference","previous_headings":"","what":"Common argument — strDesign","title":"Common argument — strDesign","text":"Common argument","code":""},{"path":"https://pkg.robjhyndman.com/stR/reference/strDesign.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Common argument — strDesign","text":"strDesign optional parameter used create design matrix. used internally library improve performance design matrix require full recalculation.","code":""},{"path":"https://pkg.robjhyndman.com/stR/reference/trace.html","id":null,"dir":"Reference","previous_headings":"","what":"Common argument — trace","title":"Common argument — trace","text":"Common argument","code":""},{"path":"https://pkg.robjhyndman.com/stR/reference/trace.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Common argument — trace","text":"trace TRUE, tracing turned .","code":""},{"path":"https://pkg.robjhyndman.com/stR/news/index.html","id":"str-07","dir":"Changelog","previous_headings":"","what":"stR 0.7","title":"stR 0.7","text":"Rob Hyndman took maintenance Added NEWS.md file track changes package. Added pkgdown site Fixed CRAN checks","code":""},{"path":"https://pkg.robjhyndman.com/stR/news/index.html","id":"str-06","dir":"Changelog","previous_headings":"","what":"stR 0.6","title":"stR 0.6","text":"CRAN release: 2023-08-10","code":""},{"path":"https://pkg.robjhyndman.com/stR/news/index.html","id":"str-05","dir":"Changelog","previous_headings":"","what":"stR 0.5","title":"stR 0.5","text":"CRAN release: 2022-02-17","code":""},{"path":"https://pkg.robjhyndman.com/stR/news/index.html","id":"str-04","dir":"Changelog","previous_headings":"","what":"stR 0.4","title":"stR 0.4","text":"CRAN release: 2018-05-18","code":""},{"path":"https://pkg.robjhyndman.com/stR/news/index.html","id":"str-03","dir":"Changelog","previous_headings":"","what":"stR 0.3","title":"stR 0.3","text":"CRAN release: 2017-01-06 Added plotBeta heuristicSTR Updated vignette","code":""},{"path":"https://pkg.robjhyndman.com/stR/news/index.html","id":"str-02","dir":"Changelog","previous_headings":"","what":"stR 0.2","title":"stR 0.2","text":"CRAN release: 2016-09-10 Added seasadj, seasadj.STR components","code":""},{"path":"https://pkg.robjhyndman.com/stR/news/index.html","id":"str-01","dir":"Changelog","previous_headings":"","what":"stR 0.1","title":"stR 0.1","text":"CRAN release: 2016-08-27 First version package CRAN","code":""}]
